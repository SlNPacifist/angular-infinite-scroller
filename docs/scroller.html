<!DOCTYPE html>

<html>
<head>
  <title>scroller.coffee</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>scroller.coffee</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <h3 id="code-conventions-">Code conventions:</h3>
<ul>
<li>Class members starting with underscore are <strong>private</strong> and should not be accessed</li>
<li>Other class members are <strong>read-only</strong></li>
<li>All the changes to class should be done using public methods</li>
<li>Every property of an object should be assigned in constructor, even if its initial value is null
or undefined. No new properties should be introduced during object lifecycle.</li>
</ul>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h3 id="-section-id-viewport_default_settings-default-settings-section-"><section id='VIEWPORT_DEFAULT_SETTINGS'>Default settings</section></h3>
<p>Default settings for viewport. If any setting is not listed in scope, it will be copied from this
object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>VIEWPORT_DEFAULT_SETTINGS =</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>If “hidden” part of viewport contents is less then <code>min</code>, new items will be rendered. If it is
more than <code>max</code>, rendered items will be destroyed. See
<a href="#ScrollerViewport._updateState"><code>ScrollerViewport._updateState</code></a> to get details on how this
is used in code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    paddingTop:
        min: <span class="hljs-number">100</span>
        max: <span class="hljs-number">150</span>
    paddingBottom:
        min: <span class="hljs-number">100</span>
        max: <span class="hljs-number">150</span></pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>Number of items in every request. See
<a href="#ScrollerViewport._tryDrawTopItem"><code>ScrollerViewport._tryDrawTopItem</code></a> and
<a href="#ScrollerViewport._tryDrawBottomItem"><code>ScrollerViewport._tryDrawBottomItem</code></a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    itemsPerRequest: <span class="hljs-number">10</span></pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>Number of milliseconds between “auto updates”. This tracks any changes that cannot be tracked
otherwise. See
<a href="#ScrollerViewport._changeAutoUpdateInterval"><code>ScrollerViewport._changeAutoUpdateInterval</code></a>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    autoUpdateInterval: <span class="hljs-number">1000</span></pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>See <a href="#ScrollerViewport._updateState"><code>ScrollerViewport._updateState</code></a> for details.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    afterScrollWaitTime: <span class="hljs-number">100</span></pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>Number of milliseconds after which viewport will allow re-checking boundary of data. See
<a href="#Buffer.beginOfDataReached"><code>Buffer.beginOfDataReached</code></a> and
<a href="#Buffer.endOfDataReached"><code>Buffer.endOfDataReached</code></a> for details.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    buffer:
        topBoundaryTimeout: <span class="hljs-number">10000</span>
        bottomBoundaryTimeout: <span class="hljs-number">10000</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Amount of additional (compared to rendered) items that buffer keeps. I.e. if items 57-69 are
rendered then buffer will keep data for items 37-89. See
<a href="#ScrollerViewport._truncateBuffer"><code>ScrollerViewport._truncateBuffer</code></a> for details</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    bufferTopPadding: <span class="hljs-number">20</span>
    bufferBottomPadding: <span class="hljs-number">20</span>
<span class="hljs-function">

<span class="hljs-title">insertAfter</span> = <span class="hljs-params">(element, target)</span> -&gt;</span>
    parent = target.parentNode
    <span class="hljs-keyword">if</span> target.nextSibling
        next = target.nextSibling
        parent.insertBefore(element, next)
    <span class="hljs-keyword">else</span>
        parent.appendChild(element)</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h3 id="-section-id-scrollerviewport-scroller-viewport-section-"><section id='ScrollerViewport'>Scroller Viewport</section></h3>
<p><code>ScrollerViewport</code> is <code>angular.js</code> controller. It tracks current state of bound element and makes
decisions to ask for new items, render or delete items.</p>
<p>Read <a href="#ScrollerViewport._updateState"><code>_updateState</code></a> documentation to understand this class state
flow.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollerViewport</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p><code>scope</code>: <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope"><code>angular.js scope</code></a>. Used
for communication with <a href="#ScrollerItemList">ScrollerItemList</a> througe events.</p>
<p><code>element</code>: <code>DOM Node</code> bound to this viewport</p>
<p><code>source</code>: could be complex object or just a function. Complex object should contain:</p>
<ul>
<li><code>initialIndex</code>: index of the element to start with</li>
<li><p><code>get</code>: <code>function(start, count, callback)</code>. This function is called whenever new data is
needed.</p>
<ul>
<li><code>start</code>: <code>int</code></li>
<li><code>count</code>: <code>int</code></li>
<li><code>callback</code>: <code>function(res)</code>. Callback should be called when needed data is ready.</li>
<li><code>res</code>: <code>array</code>. Should contain <code>count</code> items in it. If request hit boundary of data, <code>res</code>
 can contain less then <code>count</code> data or even no data at all.</li>
</ul>
</li>
</ul>
<p>If <code>source</code> is just a <code>function</code>, <code>initialIndex</code> is considered to be 0.</p>
<p><code>settings</code>: <code>object</code>. Settings object with structure similar to
<a href="#VIEWPORT_DEFAULT_SETTINGS">default settings</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    constructor: <span class="hljs-function"><span class="hljs-params">(@scope, @_element, source, settings={})</span> -&gt;</span>
        @_settings = angular.merge({}, VIEWPORT_DEFAULT_SETTINGS, settings)</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Viewport keeps track of currently rendered items in format
<code>{index: int, data: data_received_from_source_function}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_drawnItems = []

        @_setSource(source)</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Auto update makes sure we do not miss special or untrackable events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_autoUpdateHandler = <span class="hljs-literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>See <a href="#ScrollerViewport._updateStateAsync"><code>_updateStateAsync</code></a> for details.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_updatePlanned = <span class="hljs-literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>See <a href="#ScrollerViewport._updateState"><code>_updateState</code></a> for details.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_lastScrollTop = <span class="hljs-literal">null</span>
        @_lastScrollTopChange = <span class="hljs-literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>First update to start the process. <code>scroll</code> event most likely will cause actions to
perform. Finally, <code>_changeAutoUpdateInterval</code> function sets auto updates for any events
we do not track. Better later then never.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_updateStateAsync()
        @_element.addEventListener(<span class="hljs-string">'scroll'</span>, @_updateStateAsync)
        @_changeAutoUpdateInterval(@_settings.autoUpdateInterval)

    updateSettings: <span class="hljs-function"><span class="hljs-params">(settings={})</span> =&gt;</span>
        settings = angular.merge({}, VIEWPORT_DEFAULT_SETTINGS, settings)
        <span class="hljs-keyword">if</span> @_settings.autoUpdateInterval != settings.autoUpdateInterval
            @_changeAutoUpdateInterval(settings.autoUpdateInterval)
        @_settings = settings
        @_buffer.updateSettings(@_settings.buffer)

    updateSource: <span class="hljs-function"><span class="hljs-params">(source)</span> =&gt;</span>
        @_buffer.destroy()
        @_drawnItems = []
        @scope.$broadcast(<span class="hljs-string">'clear'</span>)
        @_setSource(source)

    _setSource: <span class="hljs-function"><span class="hljs-params">(source)</span> =&gt;</span>
        start = <span class="hljs-number">0</span>
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">typeof</span>(source) == <span class="hljs-string">'object'</span>
            start = source.initialIndex
            source = source.get</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p><a href="#Buffer"><code>Buffer</code></a> caches data from <code>source</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_buffer = <span class="hljs-keyword">new</span> Buffer(source, start, @_settings.buffer, @_updateBufferState)
        @_renderFrom = start
        @_topRenderAllowed = <span class="hljs-literal">false</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Updates buffer-related state (loading top, loading bottom, etc) in scope</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _updateBufferState: <span class="hljs-function">=&gt;</span>
        oldReachedTop = <span class="hljs-literal">null</span>
        oldReachedBottom = <span class="hljs-literal">null</span>
        @scope.$applyAsync =&gt;
            @scope.scrLoadingTop = @_buffer.topIsLoading()
            @scope.scrReachedTop = @_buffer.beginOfDataReached()
            @scope.scrLoadingBottom = @_buffer.bottomIsLoading()
            @scope.scrReachedBottom = @_buffer.endOfDataReached()
            <span class="hljs-keyword">if</span> oldReachedTop != @scope.scrReachedTop
                @_updateStateAsync()
                oldReachedTop = @scope.scrReachedTop
            <span class="hljs-keyword">if</span> oldReachedBottom != @scope.scrReachedBottom
                @_updateStateAsync()
                oldReachedBottom = @scope.scrReachedBottom</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_changeautoupdateinterval-section-"><section id='ScrollerViewport._changeAutoUpdateInterval'></section></h2>
<p>Sets interval for auto updates. Auto update makes sure we do not miss special or untrackable
events.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _changeAutoUpdateInterval: <span class="hljs-function"><span class="hljs-params">(interval)</span> =&gt;</span>
        clearInterval(@_autoUpdateHandler) <span class="hljs-keyword">if</span> @_autoUpdateHandler?
        @_autoUpdateHandler = setInterval(@_updateStateAsync, interval)</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_updatestate-section-"><section id='ScrollerViewport._updateState'></section></h2>
<p>Main function for this class. It performs measurements and makes decision on what to do.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _updateState: <span class="hljs-function">=&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>During “initialization” only rendering of bottom items allowed. This is done to prevent
changing of position of top (initial) element. This stage is over if content height equals
to element height (that would be enough to keep initial item in place when rendering top
items) or bottom boundary of data is reached.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> !@_topRenderAllowed
            <span class="hljs-keyword">if</span> @_element.scrollHeight &gt; @_element.offsetHeight \
            || @_buffer.endOfDataReached()
                @_topRenderAllowed = <span class="hljs-literal">true</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Firstly, check size of contents that is hidden on top. However, if you want to change
top of rendered items, you have to make sure you won’t break current scrolling process.
When user scrolls contents of viewport, it is a process stretched in time, scrollTop will
be changing gradually for 30-70 ms. If you change scrollTop in the middle of that process
any scrolling will be stopped and user will experience very stuttering scrolling. I found
no “official” ways to determine if scrolling is going on or not, so the way to overcome
this is “wait for some time and make sure scroll did not change”.</p>
<p><code>@_lastScrollTop</code> remembers last scrollTop measured and <code>@_lastScrollTopChange</code> remembers
time of measurement.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        now = <span class="hljs-keyword">new</span> Date()
        <span class="hljs-keyword">if</span> @_topRenderAllowed
            <span class="hljs-keyword">if</span> @_element.scrollTop == @_lastScrollTop \
            &amp;&amp; now - @_lastScrollTopChange &gt; @_settings.afterScrollWaitTime</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Code here assumes changing <code>@_element.scrollTop</code> is safe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> @_element.scrollTop &gt; @_settings.paddingTop.max
                    @_removeTopDrawnItem()
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> @_element.scrollTop &lt; @_settings.paddingTop.min
                    @_tryDrawTopItem()
            <span class="hljs-keyword">else</span></pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Code here assumes changing <code>@_element.scrollTop</code> is not safe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="hljs-keyword">if</span> @_element.scrollTop != @_lastScrollTop
                    @_lastScrollTop = @_element.scrollTop
                    @_lastScrollTopChange = now</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>We wanted to updated state but could not do it due to scrolling. Plan update for
the next tick.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                @_updateStateAsync()</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>Unlike top, we can change bottom any time we need.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        paddingBottom = @_element.scrollHeight - @_element.scrollTop - @_element.offsetHeight
        <span class="hljs-keyword">if</span> paddingBottom &lt; @_settings.paddingBottom.min
            @_tryDrawBottomItem()
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> paddingBottom &gt; @_settings.paddingBottom.max
            @_removeBottomDrawnItem()</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_updatestateasync-section-"><section id='ScrollerViewport._updateStateAsync'></section></h2>
<p><code>@_updateState</code> should not be called directly since it could cause multiple simultaneous
updates. <code>@_updateStateAsync</code> makes sure only one update is performed per tick.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _updateStateAsync: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_updatePlanned
        @_updatePlanned = <span class="hljs-literal">true</span>
        setTimeout =&gt;
            @_updatePlanned = <span class="hljs-literal">false</span>
            @_updateState()
        , <span class="hljs-number">0</span></pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_trydrawtopitem-section-"><section id='ScrollerViewport._tryDrawTopItem'></section></h2>
<p>Either render existing item or request more items from the top. Note that if no data available
then more data is requested, but no rendering will happen when data arrives.
<code>@_updateStateAsync</code> is called when data arrives.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _tryDrawTopItem: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">if</span> @_drawnItems.length &gt; <span class="hljs-number">0</span>
            neededIndex = @_drawnItems[<span class="hljs-number">0</span>].index - <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>
            neededIndex = <span class="hljs-number">-1</span>
        <span class="hljs-keyword">if</span> neededIndex <span class="hljs-keyword">of</span> @_buffer
            @_addTopDrawnItem({index: neededIndex, data: @_buffer[neededIndex]})
        <span class="hljs-keyword">else</span>
            @_buffer.requestMoreTopItems(@_settings.itemsPerRequest, @_updateStateAsync)</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_trydrawbottomitem-section-"><section id='ScrollerViewport._tryDrawBottomItem'></section></h2>
<p>Either render existing item or request more items from the bottom.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _tryDrawBottomItem: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">if</span> @_drawnItems.length &gt; <span class="hljs-number">0</span>
            neededIndex = @_drawnItems[@_drawnItems.length - <span class="hljs-number">1</span>].index + <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>
            neededIndex = @_renderFrom
        <span class="hljs-keyword">if</span> neededIndex <span class="hljs-keyword">of</span> @_buffer
            @_addBottomDrawnItem({index: neededIndex, data: @_buffer[neededIndex]})
        <span class="hljs-keyword">else</span>
            @_buffer.requestMoreBottomItems(@_settings.itemsPerRequest, @_updateStateAsync)</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>Simply add new item to list of drawn items and send a command to draw this item for all
<code>ScrollerItemList</code> controllers. Items should be drawn this tick so update on the next tick
will see changes and will be able to make new decisions.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _addTopDrawnItem: <span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span>
        @_drawnItems.unshift(item)
        @scope.$broadcast(<span class="hljs-string">'render-top-item'</span>, item)
        @_updateStateAsync()</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>See <code>@_addTopDrawnItem</code> for additional comments.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _addBottomDrawnItem: <span class="hljs-function"><span class="hljs-params">(item)</span> =&gt;</span>
        @_drawnItems.push(item)
        @scope.$broadcast(<span class="hljs-string">'render-bottom-item'</span>, item)
        @_updateStateAsync()</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <h2 id="-section-id-scrollerviewport-_truncatebuffer-section-"><section id='ScrollerViewport._truncateBuffer'></section></h2>
<p>This makes sure buffer does not grow infinitely. Buffer always contains more data than
rendered, paddings are configurable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _truncateBuffer: <span class="hljs-function">=&gt;</span>
        bufferMinStart = @_drawnItems[<span class="hljs-number">0</span>].index - @_settings.bufferTopPadding
        bufferMaxEnd = @_drawnItems[@_drawnItems.length - <span class="hljs-number">1</span>].index + @_settings.bufferBottomPadding
        @_buffer.truncateTo(bufferMinStart, bufferMaxEnd)

    _removeTopDrawnItem: <span class="hljs-function">=&gt;</span>
        @_drawnItems.shift()
        @scope.$broadcast(<span class="hljs-string">'remove-top-item'</span>)
        @_truncateBuffer()
        @_updateStateAsync()

    _removeBottomDrawnItem: <span class="hljs-function">=&gt;</span>
        @_drawnItems.pop()
        @scope.$broadcast(<span class="hljs-string">'remove-bottom-item'</span>)
        @_truncateBuffer()
        @_updateStateAsync()</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Public method is used by <code>ScrollerItemList</code> to preserve scroll position when adding or
removing items from the top. We assume that any change in height of contents are caused by
adding or removing of top items and compensate difference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    preserveScroll: <span class="hljs-function"><span class="hljs-params">(action)</span> =&gt;</span>
        heightBefore = @_element.scrollHeight
        scrollBefore = @_element.scrollTop
        action()
        heightDelta = @_element.scrollHeight - heightBefore
        scrollDelta = @_element.scrollTop - scrollBefore
        @_element.scrollTop += heightDelta - scrollDelta
        @_lastScrollTop = @_element.scrollTop</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <h3 id="-section-id-scrolleritemlist-scroller-item-list-section-"><section id='ScrollerItemList'>Scroller item list</section></h3>
<p><code>ScrollerItemList</code> is <code>angular.js</code> controller. It manages list of items currently rendered in
viewport.</p>
<p>Class state flow is very simple. Once instantiated, object of this class listens to viewport
events (commands) using angular.js scope for adding/removing top or bottom items.
Adds new properties to scope:</p>
<ul>
<li>scrIndex: global index of rendered item</li>
<li>scrData: data received from source function</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollerItemList</span></span>
    constructor: <span class="hljs-function"><span class="hljs-params">(@_$element, @_viewportController, @_$transclude)</span> -&gt;</span>
        @_renderedItems = []
        @_viewportController.scope.$<span class="hljs-literal">on</span>(<span class="hljs-string">'render-top-item'</span>, <span class="hljs-function"><span class="hljs-params">(_, source)</span> =&gt;</span> @_addTopItem(source))
        @_viewportController.scope.$<span class="hljs-literal">on</span>(<span class="hljs-string">'render-bottom-item'</span>, <span class="hljs-function"><span class="hljs-params">(_, source)</span> =&gt;</span> @_addBottomItem(source))
        @_viewportController.scope.$<span class="hljs-literal">on</span>(<span class="hljs-string">'remove-top-item'</span>, @_removeTopItem)
        @_viewportController.scope.$<span class="hljs-literal">on</span>(<span class="hljs-string">'remove-bottom-item'</span>, @_removeBottomItem)
        @_viewportController.scope.$<span class="hljs-literal">on</span>(<span class="hljs-string">'clear'</span>, @_clear)

    _createItem: <span class="hljs-function"><span class="hljs-params">(source, insert_point)</span> =&gt;</span>
        item = {scope: <span class="hljs-literal">null</span>, clone: <span class="hljs-literal">null</span>}
        @_$transclude (node, scope) -&gt;
            item.scope = scope
            item.clone = node[<span class="hljs-number">0</span>]
            insertAfter(item.clone, insert_point)</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Data should be applied after transclusion, otherwise item won’t see changes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        item.scope.$apply -&gt;
            item.scope.scrIndex = source.index
            item.scope.scrData = source.data
        item

    _destroyItem: <span class="hljs-function"><span class="hljs-params">(item)</span> -&gt;</span>
        item.clone.remove()
        item.scope.$destroy()

    _addTopItem: <span class="hljs-function"><span class="hljs-params">(source)</span> =&gt;</span>
        @_viewportController.preserveScroll =&gt;
            @_renderedItems.unshift(@_createItem(source, @_$element[<span class="hljs-number">0</span>]))

    _addBottomItem: <span class="hljs-function"><span class="hljs-params">(source)</span> =&gt;</span>
        <span class="hljs-keyword">if</span> @_renderedItems.length &gt; <span class="hljs-number">0</span>
            insert_point = @_renderedItems[@_renderedItems.length - <span class="hljs-number">1</span>].clone
        <span class="hljs-keyword">else</span>
            insert_point = @_$element[<span class="hljs-number">0</span>]
        @_renderedItems.push(@_createItem(source, insert_point))

    _removeTopItem: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_renderedItems.length == <span class="hljs-number">0</span>
        @_viewportController.preserveScroll =&gt;
            @_destroyItem(@_renderedItems.shift())

    _removeBottomItem: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_renderedItems.length == <span class="hljs-number">0</span>
        @_destroyItem(@_renderedItems.pop())

    _clear: <span class="hljs-function">=&gt;</span>
        @_destroyItem(item) <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> @_renderedItems
        @_renderedItems = []</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h3 id="-section-id-scrolleritemlist-buffer-section-"><section id='ScrollerItemList'>Buffer</section></h3>
<p><code>Buffer</code> manages items given by source function. It stores range of items in the form of
array-like object: <code>{start: int, length: int}</code> and every stored index is a key in this object.
Buffer assumes that only integer indexes are stored in it. It is capable of extension and
truncating stored items.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Buffer</span></span></pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>getItems</code>: <code>function(start, count, callback)</code>. See <a href="#ScrollerViewport"><code>ScrollerViewport</code></a>
constructor for details.</p>
<p><code>settings</code>: <code>object</code></p>
<ul>
<li><code>topBoundaryTimeout</code>: amount of time (ms) when hitting top boundary is considered valid.
After that time requests for top items will be allowed.</li>
<li><code>bottomBoundaryTimeout</code>: same as top <code>bottomBoundaryTimeout</code>, but for bottom boundary.</li>
</ul>
<p><code>originalStateChange</code>: <code>function()</code>. Called when buffer state (top boundary hit, loading top,
bottom boundary hit, loading bottom) could be changed. Called in constructor. Not called in
destructor.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    constructor: <span class="hljs-function"><span class="hljs-params">(@_getItems, @start, @_settings, @_originalStateChange)</span> -&gt;</span>
        @length = <span class="hljs-number">0</span>
        @_counter = <span class="hljs-number">0</span>
        @_topItemsRequestId = <span class="hljs-literal">null</span>
        @_bottomItemsRequestId = <span class="hljs-literal">null</span>
        @_topBoundaryIndex = <span class="hljs-literal">null</span>
        @_topBoundaryIndexTimestamp = <span class="hljs-literal">null</span>
        @_bottomBoundaryIndex = <span class="hljs-literal">null</span>
        @_bottomBoundaryIndexTimestamp = <span class="hljs-literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>If buffer gets destroyed, noop will be called instead of function that we got in
constructor. We cannot change _onStateChange in destructor because functions passed to
setTimeout will still be unchanged.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_onStateChange = <span class="hljs-function">=&gt;</span>
            @_originalStateChange()
        @_onStateChange()

    updateSettings: <span class="hljs-function"><span class="hljs-params">(settings)</span> =&gt;</span>
        @_settings = settings</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>make sure changes in settings change our state properly</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_onStateChange()
        <span class="hljs-keyword">if</span> @_topBoundaryIndex?
            delta = (@_topBoundaryIndexTimestamp - <span class="hljs-keyword">new</span> Date()) + settings.topBoundaryTimeout
            setTimeout(@_onStateChange, delta)
        <span class="hljs-keyword">if</span> @_bottomBoundaryIndex?
            delta = (@_bottomBoundaryIndexTimestamp - <span class="hljs-keyword">new</span> Date()) + settings.bottomBoundaryTimeout
            setTimeout(@_onStateChange, delta)</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h2 id="-section-id-buffer-requestmoretopitems-section-"><section id='Buffer.requestMoreTopItems'></section></h2>
<p>Only one request of top items may be active at a time. That ensures that multiple actions like
“scroll to bottom and back to top” does not make multiple requests.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    requestMoreTopItems: <span class="hljs-function"><span class="hljs-params">(quantity, callback)</span> =&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_topItemsRequestId?
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @beginOfDataReached()
        @_startTopRequest()
        request_id = @_topItemsRequestId
        start = @start - quantity
        end = @start
        @_getItems start, quantity, <span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Request has been canceled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> request_id != @_topItemsRequestId
            @_stopTopRequest()
            <span class="hljs-keyword">if</span> res.length == <span class="hljs-number">0</span>
                @_markTopBoundary(end)
            <span class="hljs-keyword">else</span>
                @_addItemsToStart(res)
                <span class="hljs-keyword">if</span> @start &lt; @_topBoundaryIndex
                    @_unmarkTopBoundary()
                callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h2 id="-section-id-buffer-beginofdatareached-section-"><section id='Buffer.beginOfDataReached'></section></h2>
<p>This function tracks “begin of data”. If we request top items and receive empty result, we
assume that we reached “begin of data”. We will not do any requests of top items for some
(configurable) time. After that time requests for top items will be allowed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    beginOfDataReached: <span class="hljs-function">=&gt;</span>
        now = <span class="hljs-keyword">new</span> Date()
        <span class="hljs-keyword">return</span> @start == @_topBoundaryIndex &amp;&amp;
            (now - @_topBoundaryIndexTimestamp &lt; @_settings.topBoundaryTimeout)</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Allocate new request id and make everyone know we’re changing state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _startTopRequest: <span class="hljs-function">=&gt;</span>
        @_topItemsRequestId = @_counter
        @_counter += <span class="hljs-number">1</span>
        @_onStateChange()

    _stopTopRequest: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_topItemsRequestId <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>
        @_topItemsRequestId = <span class="hljs-literal">null</span>
        @_onStateChange()

    _markTopBoundary: <span class="hljs-function"><span class="hljs-params">(topIndex)</span> =&gt;</span>
        @_topBoundaryIndex = topIndex
        @_topBoundaryIndexTimestamp = <span class="hljs-keyword">new</span> Date()
        @_onStateChange()
        setTimeout(@_onStateChange, @_settings.topBoundaryTimeout)

    _unmarkTopBoundary: <span class="hljs-function">=&gt;</span>
        @_topBoundaryIndex = <span class="hljs-literal">null</span>
        @_onStateChange()

    _addItemsToStart: <span class="hljs-function"><span class="hljs-params">(items)</span> =&gt;</span>
        @start -= items.length
        <span class="hljs-keyword">for</span> item, idx <span class="hljs-keyword">in</span> items
            <span class="hljs-keyword">this</span>[@start + idx] = item
        @length += items.length</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h2 id="-section-id-buffer-requestmorebottomitems-section-"><section id='Buffer.requestMoreBottomItems'></section></h2>
<p>See <a href="#Buffer.requestMoreTopItems"><code>@requestMoreTopItems</code></a> for additional comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    requestMoreBottomItems: <span class="hljs-function"><span class="hljs-params">(quantity, callback)</span> =&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_bottomItemsRequestId?
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @endOfDataReached()
        @_startBottomRequest()
        request_id = @_bottomItemsRequestId
        start = @start + @length
        @_getItems start, quantity, <span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span></pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Request has been canceled</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> request_id != @_bottomItemsRequestId
            @_stopBottomRequest()
            <span class="hljs-keyword">if</span> res.length == <span class="hljs-number">0</span>
                @_markBottomBoundary(start)
            <span class="hljs-keyword">else</span>
                @_addItemsToEnd(res)
                <span class="hljs-keyword">if</span> @start + @length &gt; @_bottomBoundaryIndex
                    @_unmarkBottomBoundary()
                callback()</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h2 id="-section-id-buffer-endofdatareached-section-"><section id='Buffer.endOfDataReached'></section></h2>
<p>See <a href="#Buffer.beginOfDataReached"><code>@beginOfDataReached</code></a> for additional comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    endOfDataReached: <span class="hljs-function">=&gt;</span>
        now = <span class="hljs-keyword">new</span> Date()
        <span class="hljs-keyword">return</span> @start + @length == @_bottomBoundaryIndex &amp;&amp;
            (now - @_bottomBoundaryIndexTimestamp &lt; @_settings.bottomBoundaryTimeout)</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Allocate new request id and make everyone know we’re changing state</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _startBottomRequest: <span class="hljs-function">=&gt;</span>
        @_bottomItemsRequestId = @_counter
        @_counter += <span class="hljs-number">1</span>
        @_onStateChange()

    _stopBottomRequest: <span class="hljs-function">=&gt;</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> @_bottomItemsRequestId <span class="hljs-keyword">is</span> <span class="hljs-literal">null</span>
        @_bottomItemsRequestId = <span class="hljs-literal">null</span>
        @_onStateChange()

    _markBottomBoundary: <span class="hljs-function"><span class="hljs-params">(bottomIndex)</span> =&gt;</span>
        @_bottomBoundaryIndex = bottomIndex
        @_bottomBoundaryIndexTimestamp = <span class="hljs-keyword">new</span> Date()
        @_onStateChange()
        setTimeout(@_onStateChange, @_settings.bottomBoundaryTimeout)

    _unmarkBottomBoundary: <span class="hljs-function">=&gt;</span>
        @_bottomBoundaryIndex = <span class="hljs-literal">null</span>
        @_onStateChange()

    _addItemsToEnd: <span class="hljs-function"><span class="hljs-params">(items)</span> =&gt;</span>
        <span class="hljs-keyword">for</span> item, idx <span class="hljs-keyword">in</span> items
            <span class="hljs-keyword">this</span>[@start + @length + idx] = item
        @length += items.length

    truncateTo: <span class="hljs-function"><span class="hljs-params">(start, end)</span> =&gt;</span>
        <span class="hljs-keyword">if</span> @start &lt; start
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [@start...start]
                <span class="hljs-keyword">delete</span> @[i]
            @length = Math.max(<span class="hljs-number">0</span>, @length - (start - @start))
            @start = start</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Cancel current top items request because we created a gap between items in this
request and start of buffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            @_stopTopRequest()
        cur_end = @start + @length - <span class="hljs-number">1</span>
        <span class="hljs-keyword">if</span> cur_end &gt; end
            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [cur_end...end]
                <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>[i]
            @length = Math.max(<span class="hljs-number">0</span>, @length - (cur_end - end))</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Cancel current bottom items request because we created a gap between items in this
request and end of buffer</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            @_stopBottomRequest()

    topIsLoading: <span class="hljs-function">=&gt;</span> @_topItemsRequestId?

    bottomIsLoading: <span class="hljs-function">=&gt;</span> @_bottomItemsRequestId?</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Called when data source changes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    destroy: <span class="hljs-function">=&gt;</span>
        @_topItemsRequestId = <span class="hljs-literal">null</span>
        @_bottomItemsRequestId = <span class="hljs-literal">null</span></pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p><code>@_onStateChange</code> could be called in future because it was passed to <code>setTimeout</code>.
Changing <code>@_originalStateChange</code> to noop ensures that <code>@_onStateChange</code> will not change
anything.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        @_originalStateChange = <span class="hljs-function">-&gt;</span>


angular.<span class="hljs-built_in">module</span>(<span class="hljs-string">'scroller'</span>, [])

.directive <span class="hljs-string">'scrollerViewport'</span>, <span class="hljs-function">-&gt;</span>
    restrict: <span class="hljs-string">'A'</span>
    scope: <span class="hljs-literal">true</span>
    controller: <span class="hljs-function"><span class="hljs-params">($scope, $element, $attrs)</span> -&gt;</span>
        viewportController = <span class="hljs-keyword">new</span> ScrollerViewport(
            $scope, $element[<span class="hljs-number">0</span>], $scope[$attrs.scrollerViewport], $scope[$attrs.scrollerSettings])

        $scope.$watch $attrs.scrollerSettings, <span class="hljs-function"><span class="hljs-params">(newVal)</span> -&gt;</span>
            viewportController.updateSettings(newVal)
        , <span class="hljs-literal">true</span>

        $scope.$watch $attrs.scrollerViewport, <span class="hljs-function"><span class="hljs-params">(newVal, oldVal)</span>-&gt;</span>
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">if</span> newVal == oldVal
            viewportController.updateSource(newVal)
        <span class="hljs-keyword">return</span> viewportController

.directive <span class="hljs-string">'scrollerItem'</span>, <span class="hljs-function">-&gt;</span>
    restrict: <span class="hljs-string">'A'</span>
    priority: <span class="hljs-number">1000</span>
    require: <span class="hljs-string">'^^scrollerViewport'</span>
    transclude: <span class="hljs-string">'element'</span>
    scope: <span class="hljs-literal">true</span>
    link: <span class="hljs-function"><span class="hljs-params">($scope, $element, $attrs, viewportCtrl, $transclude)</span> -&gt;</span>
        <span class="hljs-keyword">new</span> ScrollerItemList($element, viewportCtrl, $transclude)</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
